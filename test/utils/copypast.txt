function wrapperOpenQuoteMM(
        utils.bOracleSign calldata bOracleSign,
        bytes calldata signaturebOracleSign,
        utils.OpenQuoteSign calldata openQuoteSign,
        bytes calldata openQuoteSignature,
        uint256 _acceptPrice) public {

       require( keccak256(openQuoteSignature) == keccak256(bOracleSign.signatureHashOpenQuote), "Signature hash mismatch" );
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("bOracleSign(uint256 x,uint8 parity,uint256 maxConfidence,bytes32 assetHex,uint256 maxDelay,uint256 precision,uint256 imA,uint256 imB,uint256 dfA,uint256 dfB,uint256 expiryA,uint256 expiryB,uint256 timeLock,bytes signatureHashOpenQuote,uint256 nonce)"),
                bOracleSign.x,
                bOracleSign.parity,
                bOracleSign.maxConfidence,
                bOracleSign.assetHex,
                bOracleSign.maxDelay,
                bOracleSign.precision,
                bOracleSign.imA,
                bOracleSign.imB,
                bOracleSign.dfA,
                bOracleSign.dfB,
                bOracleSign.expiryA,
                bOracleSign.expiryB,
                bOracleSign.timeLock,
                keccak256(abi.encodePacked(bOracleSign.signatureHashOpenQuote)),
                bOracleSign.nonce
            )
        );
        bytes32 hash = _hashTypedDataV4(structHash);
        address signer = ECDSA.recover(hash, signaturebOracleSign);

        oracle.deployBOraclePion(
            bOracleSign.x, bOracleSign.parity, bOracleSign.maxConfidence, bOracleSign.assetHex, bOracleSign.maxDelay, bOracleSign.precision, 
            bOracleSign.imA, bOracleSign.imB, bOracleSign.dfA, bOracleSign.dfB, 
            bOracleSign.expiryA, bOracleSign.expiryB, bOracleSign.timeLock, 1 
        );
        open.openQuoteSigned(openQuoteSign, openQuoteSignature, signer, pio.getBOracleLength() - 1, msg.sender);
        open.acceptQuotewrapper(pio.getBContractLength() - 1, _acceptPrice, msg.sender);
    }


    function openQuoteSigned( 
        utils.OpenQuoteSign calldata openQuoteSign,
        bytes calldata signHash,
        address wrapperSigner,
        uint256 bOracleId,
        address sender
        ) public {

        bytes32 structHash = keccak256(abi.encode(
            keccak256("Quote(bool isLong,uint256 bOracleId,uint256 price,uint256 amount,uint256 interestRate,bool isAPayingAPR,address frontEnd,address affiliate,address authorized,uint256 nonce)"),
            openQuoteSign.isLong,
            openQuoteSign.bOracleId,
            openQuoteSign.price,
            openQuoteSign.amount,
            openQuoteSign.interestRate,  
            openQuoteSign.isAPayingAPR,
            openQuoteSign.frontEnd,
            openQuoteSign.affiliate,
            openQuoteSign.authorized,
            openQuoteSign.nonce
            ));

        bytes32 hash = _hashTypedDataV4(structHash);
        address signer = ECDSA.recover(hash, signHash);
        require((pio.getCancelledOpenQuotes(signHash, signer)  + pio.getCancelTimeBuffer()) >= block.timestamp || pio.getCancelledOpenQuotes(signHash, signer)  == 0, "Quote expired");
        pio.setCancelledOpenQuotes(signHash, signer, 1) ;

        require(openQuoteSign.authorized == address(0) || sender == openQuoteSign.authorized, "Invalid signature or unauthorized");
        require(wrapperSigner == signer, "signers mismatch");
        require(msg.sender == pio.getPIONERV1WRAPPERADDRESS(), "Invalid sender");

        openQuote(openQuoteSign.isLong, bOracleId, openQuoteSign.price, openQuoteSign.amount, openQuoteSign.interestRate, openQuoteSign.isAPayingAPR, openQuoteSign.frontEnd, openQuoteSign.affiliate, signer);
        emit openQuoteSignedEvent( pio.getBContractLength(), signHash);
    }